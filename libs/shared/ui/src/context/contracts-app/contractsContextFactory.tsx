import { merge } from 'merge-anything';
import React, {
  createContext,
  Dispatch,
  FC,
  PropsWithChildren,
  useCallback,
  useContext,
  useEffect,
  useReducer,
  useRef,
} from 'react';
import { useQueryClient } from 'react-query';
import invariant from 'ts-invariant';

import { useEthersAppContext } from '../../context';
import { invalidateCache, isValidEthersAdaptor } from '../../functions';
import {
  TAppContractsContext,
  TBaseContractExtended,
  TConnectorList,
  TContractConnector,
  TContractsByChainId,
  TContractsByName,
  TEthersAdaptor,
  TTypedContract,
} from '../../models';
import { keyNamespace } from '../../models/constants';

/**
 * i've added comment headers since this is a large file due to the factory function
 */

/**
 * #### Summary
 * Props for the ContractContext generated by the contractContextFactory
 *
 * @category ContractAppContext
 */
export type TContractsContextProps = {
  ethersContextKey?: string | undefined;
};

/* *************** **************** ******************** */
/* *************** Actions & Dispatch ****************** */
/* *************** **************** ******************** */

type TActionConnectToContract<GContractNames extends string> = {
  type: 'CONNECT_TO_CONTRACT';
  payload: {
    contractName: GContractNames;
    ethersAdaptor: TEthersAdaptor;
  };
};
type TActionConnectAllToContracts = {
  type: 'CONNECT_TO_CONTRACTS_WITH_ADAPTOR';
  payload: {
    ethersAdaptor: TEthersAdaptor | undefined;
  };
};
type TActionAddContractConnectors<GAppConnectorList> = {
  type: 'ADD_CONTRACT_CONNECTORS';
  payload: {
    appContractConnectorList: GAppConnectorList;
  };
};
type TActionSetContractConnectors<GAppConnectorList> = {
  type: 'SET_CONTRACT_CONNECTORS';
  payload: {
    appContractConnectorList: GAppConnectorList;
  };
};
type TActions<GContractNames extends string, GAppConnectorList> =
  | TActionConnectToContract<GContractNames>
  | TActionConnectAllToContracts
  | TActionAddContractConnectors<GAppConnectorList>
  | TActionSetContractConnectors<GAppConnectorList>;

export type TContractsContextActions<
  GContractNames extends string,
  GAppConnectorList
> = {
  connectToAllContractsAction: (
    appContractConnectorList: GAppConnectorList,
    ethersAdaptor: TEthersAdaptor | undefined
  ) => void;
  connectToContractAction: (
    contractName: GContractNames,
    ethersAdaptor: TEthersAdaptor
  ) => void;
  setContractConnectors: (appContractConnectorList: GAppConnectorList) => void;
  addContractConnectors: (appContractConnectorList: GAppConnectorList) => void;
  dispatch: Dispatch<TActions<GContractNames, GAppConnectorList>>;
};

/* *************** ********************* ****************** */
/* *************** üè≠ Contract Factory üè≠ ****************** */
/* *************** ********************* ****************** */

/**
 * #### Summary
 * This is the factory function that creates the ContractContext and returns the hooks you can use to access typed contracts through out your app.
 *
 * ##### ‚úèÔ∏è Notes
 * - See [this for an example](https://github.com/scaffold-eth/scaffold-eth-typescript/blob/release/packages/vite-app-ts/src/config/appContracts.config.ts) for an example of how to use this.
 *
 * @category ContractAppContext
 * @template GContractNames A type that represents the names of the contracts you want to access.  Should be `keyof ReturnType<loadAppContractConnectors>`, where `loadAppContractConnectors` is the function that returns the contract connectors config.
 * @template GAppConnectorList A type are the list of contracts and their connectors.  Should be `ReturnType<loadAppContractConnectors>`, where `loadAppContractConnectors` is the function that returns the contract connectors config.
 * @template GContractConnector TTypedContract<GContractNames, GAppConnectorList> allows the factory to strictly type contracts for the react hooks.  Should be `TTypedContract<keyof keyof ReturnType<loadAppContractConnectors>, ReturnType<loadAppContractConnectors>>`, where `loadAppContractConnectors` is the function that returns the contract connectors config.
 * @param loadAppContractConnectors A function that returns a list of app contract connectors. See [this for an example](https://github.com/scaffold-eth/scaffold-eth-typescript/blob/release/packages/vite-app-ts/src/config/appContracts.config.ts)
 * @returns A context for contracts, hook to access contracts, hook to load contracts, hook to connect to contracts in a network
 */
export const contractsContextFactory = <
  GContractNames extends string,
  GAppConnectorList extends TConnectorList<
    GContractNames,
    TBaseContractExtended<GContractNames>
  >,
  GContractsTypes extends ReturnType<
    GAppConnectorList[Extract<GContractNames, string>]['connect']
  >
>(
  loadAppContractConnectors: () => GAppConnectorList | undefined
): {
  /**
   * #### Summary
   * This is the context for contracts that lets you access your contracts anywhere in your app.  You need to wrap your app in it.  [See this example](https://github.com/scaffold-eth/scaffold-eth-typescript/blob/release/packages/vite-app-ts/src/App.tsx)
   *
   * @category ContractAppContext
   */
  ContractsAppContext: FC<PropsWithChildren<TContractsContextProps>>;
  useAppContractsActions: () =>
    | TContractsContextActions<GContractNames, GAppConnectorList>
    | undefined;
  /**
   * #### Summary
   * This hook allows you to get the contracts attached to a particular network.
   *
   * ##### ‚úèÔ∏è Notes
   * To be used with {@link useConnectAppContracts} which needs to be called in your app to connect to the contracts in a particular network.
   *
   * @category ContractAppContext
   */
  useAppContracts: <GContractName extends GContractNames>(
    contractName: GContractName,
    chainId: number | undefined
  ) => TTypedContract<GContractName, GAppConnectorList> | undefined;
  /**
   * #### Summary
   * This hook needs to be called in your app to load all your app contracts
   *
   * @category ContractAppContext
   */
  useLoadAppContracts: () => void;
  /**
   * #### Summary
   * This hook needs to be called in your app to connect your app to a network
   *
   * @category ContractAppContext
   */
  useConnectAppContracts: (adaptor: TEthersAdaptor | undefined) => void;
} => {
  type GAppContractsContext = TAppContractsContext<
    GContractNames,
    GContractsTypes
  >;

  /* *************** ******** *************************** */
  /* *************** Helpers Functions ****************** */
  /* *************** ******** *************************** */
  const defaultAppContractsContext = (): GAppContractsContext => {
    return {
      contractConnectors: {},
      contractsByName: {},
      contractsByChainId: {},
    } as GAppContractsContext;
  };

  /**
   * Create context state
   * @param appContractConnectorList
   * @returns
   * @internal
   */
  const initalizeState = (
    appContractConnectorList: GAppConnectorList
  ): GAppContractsContext => {
    const state = defaultAppContractsContext();
    state.contractConnectors =
      appContractConnectorList as unknown as GAppContractsContext['contractConnectors'];
    return state;
  };

  /**
   * Helper function for immutability of state
   * @param state
   * @returns
   * @internal
   */
  const cloneContextState = (
    state: GAppContractsContext
  ): GAppContractsContext => {
    const newState = defaultAppContractsContext();
    newState.contractConnectors = { ...state.contractConnectors };
    newState.contractsByName = { ...state.contractsByName };
    newState.contractsByChainId = { ...state.contractsByChainId };

    return newState;
  };

  const sortContractsByChainId = (
    contractsByName: TContractsByName<GContractNames, GContractsTypes>
  ): TContractsByChainId<GContractNames, GContractsTypes> => {
    let contractsByChainId: TContractsByChainId<
      GContractNames,
      GContractsTypes
    > = {};

    const names: GContractNames[] = Object.keys(
      contractsByName
    ) as GContractNames[];
    names.forEach((name) => {
      const chainIds = Object.keys(contractsByName[name]).map(Number);
      chainIds.forEach((chainId) => {
        const data = {
          [chainId]: { [name]: contractsByName[name][chainId] },
        } as TContractsByName<GContractNames, GContractsTypes>;
        const temp = merge(contractsByChainId, data);
        contractsByChainId = temp as TContractsByChainId<
          GContractNames,
          GContractsTypes
        >;
      });
    });
    return contractsByChainId;
  };

  const sortContractsByName = (
    contractsByChainId: TContractsByChainId<GContractNames, GContractsTypes>
  ): TContractsByName<GContractNames, GContractsTypes> => {
    let contractsByName: TContractsByName<GContractNames, GContractsTypes> =
      {} as TContractsByName<GContractNames, GContractsTypes>;

    const chainIds = Object.keys(contractsByChainId).map(Number);
    chainIds.forEach((chainId) => {
      const names = Object.keys(
        contractsByChainId[chainId]
      ) as GContractNames[];
      names.forEach((name) => {
        const data = {
          [name]: { [chainId]: contractsByChainId[chainId][name] },
        };
        const temp = merge(contractsByName, data);
        contractsByName = temp as TContractsByName<
          GContractNames,
          GContractsTypes
        >;
      });
    });

    return contractsByName;
  };

  const removeInvalidContracts = (
    state: GAppContractsContext,
    ethersAdaptor: TEthersAdaptor | undefined
  ): GAppContractsContext => {
    if (ethersAdaptor?.chainId != null) {
      const newState = cloneContextState(state);
      const chainId = ethersAdaptor.chainId;
      delete newState.contractsByChainId[chainId];

      newState.contractsByName = sortContractsByName(
        newState.contractsByChainId
      );
      return newState;
    }
    return state;
  };

  /* *************** ******** ************************** */
  /* *************** Action Functions ****************** */
  /* *************** ******** ************************** */

  const connectToContractWithAdaptor = (
    connector: TContractConnector<GContractNames, GContractsTypes>,
    adaptor: TEthersAdaptor
  ): GContractsTypes | undefined => {
    if (adaptor == null || !isValidEthersAdaptor(adaptor)) {
      console.warn(
        'No valid ethers adaptor provided.  Skipping contract connection'
      );
      return undefined;
    }

    const { signer, provider } = adaptor;
    const signerOrProvider = signer ?? provider;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const chainId = adaptor.chainId!;
    const contractAddress = connector?.config?.[chainId]?.address;
    if (contractAddress != null && signerOrProvider != null) {
      const contract = connector.connect(
        connector.config[chainId].address,
        signerOrProvider
      );
      if (contract != null) {
        return contract;
      }
    }

    // error handling
    if (connector.config[chainId] != null) {
      console.warn(
        'ContractConnector requires signer with the same chainId to connect contract'
      );
    }
    console.log(
      `Couldn't connect to contract ${
        connector?.contractName
      }:   signer chainId: ${chainId}, config: ${JSON.stringify(
        connector?.config
      )}.`
    );
    console.log(
      'üôÖüèΩ‚Äç‚ôÇÔ∏è Please make sure the correct network is connected and the contract is deployed.'
    );
    return undefined;
  };

  /**
   * Internal function to connect to all contracts
   * @param payload
   * @returns
   * @internal
   */
  const connectToAllContracts = (
    state: GAppContractsContext,
    ethersAdaptor: TEthersAdaptor | undefined
  ): GAppContractsContext => {
    if (ethersAdaptor == null || !isValidEthersAdaptor(ethersAdaptor)) {
      invariant.log('connectToAllContracts: Invalid ethers adaptor');
      return removeInvalidContracts(state, ethersAdaptor);
    }
    const newState = cloneContextState(state);

    const { chainId, signer, provider } = ethersAdaptor;
    const providerOrSigner = signer ?? provider;
    for (const contractName in newState.contractConnectors) {
      const connector = newState.contractConnectors[contractName];
      if (
        chainId &&
        connector.config[chainId] != null &&
        providerOrSigner != null
      ) {
        const contract = connectToContractWithAdaptor(connector, ethersAdaptor);
        const data = {
          [contractName]: { [chainId]: contract },
        } as TContractsByName<GContractNames, GContractsTypes>;
        newState.contractsByName = merge(
          newState.contractsByName,
          data
        ) as TContractsByName<GContractNames, GContractsTypes>;
      }
    }
    newState.contractsByChainId = sortContractsByChainId(
      newState.contractsByName
    );
    return newState;
  };

  /**
   * Internal function to connect to a single contract
   * @param state
   * @param payload
   * @returns
   * @internal
   */
  const connectToContract = (
    state: GAppContractsContext,
    contractName: GContractNames,
    ethersAdaptor: TEthersAdaptor | undefined
  ): GAppContractsContext => {
    if (ethersAdaptor == null || !isValidEthersAdaptor(ethersAdaptor)) {
      invariant.log('connectToAllContracts: Invalid ethers adaptor');
      return removeInvalidContracts(state, ethersAdaptor);
    }

    const newState = cloneContextState(state);
    const { chainId } = ethersAdaptor;
    const contractConnector = newState.contractConnectors[contractName];

    if (chainId && contractConnector.config[chainId] != null) {
      const contract = connectToContractWithAdaptor(
        contractConnector,
        ethersAdaptor
      );
      newState.contractsByName[contractConnector.contractName] = {};
      const temp = newState.contractsByName[contractConnector.contractName];
      temp[chainId] = contract;
      newState.contractsByChainId = sortContractsByChainId(
        newState.contractsByName
      );
    }
    return newState;
  };

  /**
   *
   * @param state
   * @param action
   * @returns
   */
  const reducer = (
    state: GAppContractsContext,
    action: TActions<GContractNames, GAppConnectorList>
  ): GAppContractsContext => {
    switch (action.type) {
      case 'CONNECT_TO_CONTRACT': {
        return connectToContract(
          state,
          action.payload.contractName,
          action.payload.ethersAdaptor
        );
      }
      case 'CONNECT_TO_CONTRACTS_WITH_ADAPTOR': {
        return connectToAllContracts(state, action.payload.ethersAdaptor);
      }
      case 'ADD_CONTRACT_CONNECTORS': {
        const newState = initalizeState(
          action.payload.appContractConnectorList
        );
        // @ts-expect-error - we know it's a valid state
        const newValue = merge(state, newState) as GAppContractsContext;
        return newValue;
      }
      case 'SET_CONTRACT_CONNECTORS': {
        const newState = initalizeState(
          action.payload.appContractConnectorList
        );
        return newState;
      }
    }
    return state;
  };

  /* *************** ******** ****************** */
  /* *************** Contexts ****************** */
  /* *************** ******** ****************** */
  /**
   * @internal
   */
  const ContractsActionsContext = createContext<
    TContractsContextActions<GContractNames, GAppConnectorList> | undefined
  >(undefined);

  const useAppContractsActions = ():
    | TContractsContextActions<GContractNames, GAppConnectorList>
    | undefined => {
    return useContext(ContractsActionsContext);
  };

  /**
   *
   * @internal
   */
  const ContractsStateContext = createContext<GAppContractsContext | undefined>(
    undefined
  );
  const useContractsState = (): Readonly<GAppContractsContext> | undefined => {
    return useContext(ContractsStateContext);
  };

  /* *************** ******** *************** */
  /* *************** Hooks ****************** */
  /* *************** ******** *************** */

  /**
   * Get Contracts for the given contract name
   * @param contractName
   * @param chainId
   * @returns
   */
  const useAppContracts = <GContractName extends GContractNames>(
    contractName: GContractName,
    chainId: number | undefined
  ): TTypedContract<GContractName, GAppConnectorList> | undefined => {
    const contractsState = useContractsState();
    const ethersContext = useEthersAppContext();
    const contract =
      contractsState?.contractsByName?.[contractName]?.[chainId ?? -1]; // -1 is unknown chainId
    const contractConnector =
      contractsState?.contractConnectors?.[contractName];
    const chainIdRef = useRef(-1);

    // just making sure app is initalized before spamming console logs
    // connector abi initialized, ethers context is initalized
    if (
      contract == null &&
      ethersContext?.chainId != null &&
      contractConnector?.abi != null &&
      chainId === chainIdRef.current
    ) {
      console.warn(
        `‚ö†Ô∏è Contract ${contractName} not found on chain ${chainId}.`
      );
      console.warn(
        `üôãüèΩ‚Äç‚ôÇÔ∏è 1. Did you setup the contract in the config ? 2. Did you call useLoadAppContracts with an adaptor that has the correct chainId ?`
      );
      chainIdRef.current = chainId;
    }

    if (contract) {
      return contract as TTypedContract<GContractName, GAppConnectorList>;
    }
    return undefined;
  };

  /**
   *
   * @param adaptor
   */
  const useLoadAppContracts = (): void => {
    const actions = useAppContractsActions();
    const queryClient = useQueryClient();

    const load = useCallback(() => {
      if (loadAppContractConnectors != null) {
        const connectors = loadAppContractConnectors();
        if (connectors != null && actions != null) {
          actions.dispatch({
            type: 'SET_CONTRACT_CONNECTORS',
            payload: { appContractConnectorList: connectors },
          });
          invalidateCache(queryClient, keyNamespace.contracts);
        }
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    useEffect(() => {
      void load();
    }, [load]);
  };

  const useConnectAppContracts = (
    adaptor: TEthersAdaptor | undefined
  ): void => {
    const actions = useAppContractsActions();
    const queryClient = useQueryClient();
    const validAdaptorState = isValidEthersAdaptor(adaptor);

    const connect = useCallback(() => {
      if (adaptor?.chainId != null && actions != null) {
        actions.dispatch({
          type: 'CONNECT_TO_CONTRACTS_WITH_ADAPTOR',
          payload: { ethersAdaptor: adaptor },
        });
        invalidateCache(queryClient, keyNamespace.contracts);
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
      adaptor?.provider,
      adaptor?.signer,
      adaptor?.chainId,
      adaptor?.account,
      validAdaptorState,
    ]);

    useEffect(() => {
      void connect();
    }, [connect]);
  };

  /* *************** ******** *************************** */
  /* *************** Context Component ****************** */
  /* *************** ******** *************************** */

  /**
   * #### Summary
   *
   *
   * @category ContractContext
   *
   * @param props
   * @returns
   */
  const ContractsAppContext: FC<TContractsContextProps> = (
    props: PropsWithChildren<TContractsContextProps>
  ) => {
    const [rState, dispatch] = useReducer(
      reducer,
      initalizeState({} as GAppConnectorList)
    );

    const connectToContractAction = useCallback(
      (contractName: GContractNames, ethersAdaptor: TEthersAdaptor): void => {
        dispatch({
          type: 'CONNECT_TO_CONTRACT',
          payload: { contractName, ethersAdaptor },
        });
      },
      []
    );

    const connectToAllContractsAction = useCallback(
      (ethersAdaptor: TEthersAdaptor | undefined): void => {
        dispatch({
          type: 'CONNECT_TO_CONTRACTS_WITH_ADAPTOR',
          payload: { ethersAdaptor },
        });
      },
      []
    );

    const setContractConnectors = useCallback(
      (appContractConnectorList: GAppConnectorList) => {
        dispatch({
          type: 'SET_CONTRACT_CONNECTORS',
          payload: { appContractConnectorList },
        });
      },
      []
    );

    const addContractConnectors = useCallback(
      (appContractConnectorList: GAppConnectorList) => {
        dispatch({
          type: 'ADD_CONTRACT_CONNECTORS',
          payload: { appContractConnectorList },
        });
      },
      []
    );

    return (
      <ContractsActionsContext.Provider
        value={{
          dispatch,
          connectToAllContractsAction,
          connectToContractAction,
          setContractConnectors,
          addContractConnectors,
        }}
      >
        <ContractsStateContext.Provider value={rState}>
          {props.children}
        </ContractsStateContext.Provider>
      </ContractsActionsContext.Provider>
    );
  };

  return {
    ContractsAppContext,
    useAppContractsActions,
    useAppContracts,
    useLoadAppContracts,
    useConnectAppContracts,
  };
};
